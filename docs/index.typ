#import "lib/gost.typ": *

#show: init


// TODO: Титульный лист

#heading(numbering: none)[Задание на курсовой проект]


В соответстсвии с методическими указаниями для выполнения данной курсовой работы, вариант задания определяется на основе последних трёх цифр студенческого билета. Мои последние цифры студенческого билета: 624. На основе этих цифр получил следующий вариант задания:

- предметная область: "Обслуживание читателей в библиотеке" ($624 mod 6 = 0$); 
- метод хеширования: открытое ($624 mod 4 = 0$);
- метод сортировки: включением ($624 mod 7 = 1$);
- вид списка: слоеный ($624 mod 5 = 4$);
- метод обхода дерева: симметричный ($624 mod 3 = 0$);
- алгоритм поиска слова в тексте: Бойера-Мура ($624 mod 2 = 0$).


Ниже приведено полное описание предметной области и требований к информационной системе.

1\. Информационная система для предметной области «Обслуживание читателей в библиотеке» должна осуществлять ввод, хранение, обработку и вывод данных о:

– читателях;

– книгах;

– выдаче и приеме книг от читателей.

2. Данные о каждом читателе должны содержать:
  
– Номер читательского билета – строка формата "ANNNN-YY",
где A – буква, обозначающая права доступа читателя (А – только
абонемент, Ч – только читальный зал, В – читальный зал и абонемент); NNNN – порядковый номер регистрации (цифры); YY – последние две цифры номера года регистрации;

    – ФИО – строка;

    – Год рождения – целое;
    
    – Адрес – строка;
    
    – Место работы/учебы – строка.

Примечание: длина строк (кроме номера читательского билета)
определяется студентом самостоятельно.

3. Данные о читателях должны быть организованны в видехеш-таблицы, первичным ключом которой является «номер читательского билета». Метод хеширования определяется вариантом задания.

4. Данные о каждой книге должны содержать:

– Шифр – строка формата «NNN.MMM», где NNN – номер тематического раздела (цифры); MMM – порядковый номер книги в разделе (цифры);

– Автор(ы) – строка;

– Название – строка;

– Издательство – строка;

– Год издания – целое;

– Количество экземпляров всего – целое;

– Количество экземпляров в наличии – целое.

Примечание: длина строк (кроме Шифра) определяется студентом самостоятельно.

5. Данные о книгах должны быть организованны в виде АВЛ-дерева поиска, упорядоченного по "Шифру".

6. Данные о выдаче или приеме книг от читателей должны содержать:
– Номер читательского билета – строка, формат которой соответствует аналогичной строке в данных о читателях;

– Шифр – строка, формат которой соответствует аналогичной строке в данных о книгах;

– Дата выдачи – строка;

– Дата возврата – строка.

Примечания:


1. Наличие в этих данных записи, содержащей в поле «Номер читательского билета» значение X и в поле «Шифр» значение Y, означает выдачу читателю с номером читательского билета X экземпляра книги с шифром Y . Отсутствие такой записи означает, что читателю с номером читательского билета X не выдавался ни один экземпляр книги с шифром Y.

2. Одному читателю может быть выдано несколько книг, и экземпляры одной книги могут быть выданы нескольким читателям. Таким образом, могут быть данные, имеющие повторяющиеся значения в своих полях.

7. Данные о выдаче или приеме книг от читателей должны быть организованны в виде списка, который упорядочен по первичному ключу – «Шифр». Вид списка и метод сортировки определяются вариантом задания.

8. Информационная система «Обслуживание читателей в библиотеке» должна осуществлять:

– регистрацию нового читателя;

– снятие с обслуживания читателя;

– просмотр всех зарегистрированных читателей;

– очистку данных о читателях;

– поиск читателя по номеру читательского билета. Результаты поиска – все сведения о найденном читателе и шифры книг, которые ему выданы;

– поиск читателя по ФИО. Результаты поиска – список найденных читателей с указанием номера читательского билета и ФИО;

– добавление новой книги;

– удаление сведений о книге;

– просмотр всех имеющихся книг;

– очистку данных о книгах;

– поиск книги по шифру. Результаты поиска – все сведения
о найденной книге, а также номера читательских билетов и ФИО
читателей, которым выданы экземпляры этой книги;

– поиск книги по фрагментам ФИО автора(ов) или названия.
Результаты поиска – список найденных книг с указанием шифра,
автора(ов), названия, издательства, года издания и количества экземпляров в наличии;

– регистрацию выдачи экземпляра книги читателю;

– регистрацию приема экземпляра книги от читателя.

9. Состав данных о читателе или книге, выдаваемых при про-
смотре всех зарегистрированных читателей или просмотре всех
имеющихся книг, определяется студентом самостоятельно, но должен содержать не менее двух полей.

10. Метод поиска читателя по ФИО определяется студентом
самостоятельно. Выбранный метод необходимо сравнить с альтер-
нативными методами.

11. Поиск книги по фрагментам ФИО автора(ов) или названия должен осуществляться путем систематического обхода АВЛ- дерева поиска. Метод обхода определяется вариантом задания. При поиске книги по фрагментам ФИО автора(ов) или названия могут быть заданы как полное ФИО автора(ов) или названия, так и их части (например, ФИО одного из нескольких авторов, одно слово или часть слова из названия). Для обнаружения заданного фрагмента в полном ФИО автора(ов) или названии должен применяться алгоритм поиска слова в тексте, указанный в варианте задания.

12. Регистрация выдачи экземпляра книги читателю должна осуществляться только при наличии свободных экземпляров выдаваемой книги (значение поля «Количество экземпляров в наличии» для соответствующей книги больше нуля).


13. При регистрации выдачи экземпляра книги или приема экземпляра книги от читателя должно корректироваться значение поля «Количество экземпляров в наличии» для соответствующей книги.
14. При снятии с обслуживания читателя должны быть учтены и обработаны ситуации, когда у читателя имеются выданные книги. Аналогичным образом следует поступать и с удалением сведений о книгах.

#pagebreak()
#ch[ВВЕДЕНИЕ]

Автоматизация процессов обработки информации является необходимым условием эффективного функционирования любой организации. Библиотечные системы, оперирующие огромными массивами данных о книжном фонде и читателях, остро нуждаются в использовании оптимальных алгоритмов и структур данных для обеспечения высокой скорости поиска, добавления и редактирования записей.

Данная курсовая работа посвящена разработке информационной системы «Обслуживание читателей в библиотеке». Особенностью проекта является не просто создание базы данных, а реализация фундаментальных структур данных и алгоритмов, обеспечивающих высокую производительность системы при выполнении типовых операций.

Актуальность работы заключается в необходимости изучения и практического применения сложных программных структур, таких как сбалансированные деревья, хеш-таблицы и многоуровневые списки, которые лежат в основе современных систем управления базами данных (СУБД), файловых систем и поисковых движков.

#pagebreak()
= Алгоритмы и структуры данных

== Структуры данных

=== Хеш-таблица с открытым хешированием

Хеширование -- это метод организации данных в виде таблицы, при котором место хранения элемента "вычисляется" с помощью специальной хеш-функции $h$ по значению его ключа.

В данной работе согласно заданию, для хранения данных о читателях используется хеш-таблица с открытым хешированием. Этот метод позволяет эффективно обрабатывать коллизии, возникающие при совпадении хеш-значений разных ключей, путем использования цепочек (линейных списков) для хранения всех элементов, попавших в одну "ячейку" таблицы.

На рисунке @hashtable представлено схематическое изображение хеш-таблицы с открытым хешированием.


#figure(
  image("images/hashtable.svg", width: 70%),
  caption: "Схема хеш-таблицы с открытым хешированием (метод цепочек)"
) <hashtable>

В данной работе хеш-функция принимает на вход номер читательского билета формата "ANNNN-YY" и вычисляет его хеш-код средствами встроенной функции языка Kotlin, после чего результат берётся по модулю размера таблицы: $h(k) = |"hashCode"(k)| mod m$, где $m$ -- размер массива ячеек таблицы.

При возникновении коллизии новый элемент добавляется в начало цепочки соответствующей ячейки. Поиск элемента выполняется за $O(1)$ в среднем случае и $O(n)$ в наихудшем случае, когда все элементы попадают в одну ячейку. Удаление элемента также выполняется за $O(1)$ в среднем.

=== Сбалансированное АВЛ-дерево поиска

Дерево -- это структура данных, являющаяся частным случаем ориентированного графа, в которой есть один корень (узел без входящих дуг), а во все остальные узлы входит ровно одна дуга.

АВЛ-дерево -- это разновидность сбалансированного двоичного дерева поиска, в котором для каждого узла выполняется условие балансировки: разница высот левого и правого поддеревьев не превышает единицы. Это обеспечивает гарантированное время выполнения основных операций (поиск, вставка, удаление) в $O(log n)$.

Каждый узел дерева хранит данные о книге, а также ссылки на левое и правое поддерево. Упорядочивание ведётся по шифру книги формата "NNN.MMM", где шифры сравниваются лексикографически: сначала по номеру раздела NNN, затем по порядковому номеру MMM.

На рисунке @avltree представлен пример АВЛ-дерева с указанием баланса каждого узла (значение показывает разность высоты правого и левого поддеревьев).

#figure(
  image("images/avl_tree.svg", width: 55%),
  caption: "Пример АВЛ-дерева с показателями баланса узлов"
) <avltree>

При вставке нового элемента выполняется стандартная вставка как в двоичное дерево поиска, после чего по пути от вставленного узла к корню проверяется условие балансировки. Если для некоторого узла баланс становится равным $+2$ или $-2$, выполняется соответствующий поворот: малый левый, малый правый, большой левый или большой правый. Удаление узла с двумя потомками выполняется через замену значения на минимальный элемент правого поддерева с последующим удалением этого минимума и перебалансировкой.

=== Слоеный список

Слоеный список (skip list) -- это вероятностная структура данных, представляющая собой упорядоченный связный список, дополненный несколькими уровнями "экспресс-указателей", которые позволяют пропускать большие фрагменты списка при поиске. 


Нижний уровень (уровень 0) представляет собой обычный отсортированный однонаправленный связный список, содержащий все элементы. Каждый последующий уровень является "разреженной" копией нижнего: элемент присутствует на уровне $i+1$ с некоторой фиксированной вероятностью $p$ (обычно $1/2$ или $1/4$). Таким образом, верхний уровень содержит лишь несколько элементов, служащих "ориентирами" при поиске.

На рисунке @skiplist приведена схема классического слоеного списка с 4 уровнями и 10 элементами.

#figure(
  image("images/skip_list.svg", width: 85%),
  caption: "Схема слоеного списка (максимальный уровень равен 4)"
) <skiplist>

В данной работе реализован детерминированный вариант слоеного списка для хранения данных о выдачах книг. В отличие от классического вероятностного варианта, здесь используются два дополнительных указателя для каждого узла:

- nextBookGroup -- указатель на первый узел следующей группы записей с другим шифром книги;
- nextReaderRecord -- указатель на первый узел следующей группы записей с другим номером читательского билета.

Список всегда отсортирован по шифру книги. Основной уровень (next) содержит все элементы в порядке возрастания шифра. Указатели nextBookGroup и nextReaderRecord обновляются после каждой вставки и удаления, обеспечивая ускоренный переход между группами при поиске.

Поиск по шифру книги использует указатели nextBookGroup для пропуска целых групп записей с другими шифрами, что снижает число сравнений по сравнению с линейным перебором. Поиск по читательскому билету использует указатели nextReaderRecord аналогичным образом.

== Алгоритмы

=== Алгоритм сортировки включением

Сортировка включением (insertion sort) -- один из наиболее простых алгоритмов сортировки, при котором элементы обрабатываются последовательно, и каждый новый элемент вставляется на правильную позицию в уже отсортированную часть последовательности.

Алгоритм работает следующим образом. Для вставки нового элемента со значением $x$ в уже отсортированный список выполняется обход с начала до тех пор, пока не будет найдена позиция, в которой значение следующего элемента превышает $x$. После нахождения этой позиции новый элемент вставляется перед ней.

В данной работе сортировка включением применяется при вставке новой записи о выдаче книги в слоеный список. Список поддерживается отсортированным по шифру книги. При добавлении нового узла выполняется следующая последовательность действий:

+ Если список пуст или шифр нового элемента меньше шифра головы списка, новый узел становится головой.
+ Иначе список обходится от начала, пока следующий элемент существует и его шифр не больше шифра нового элемента.
+ Новый узел вставляется после найденной позиции.
+ После вставки обновляются все дополнительные указатели (nextBookGroup и nextReaderRecord).

Временная сложность одной операции вставки составляет $O(n)$ в наихудшем случае, где $n$ -- текущее число элементов в списке. Поскольку список всегда хранится в отсортированном состоянии, дополнительная сортировка при выводе не требуется.

=== Алгоритм Бойера-Мура для поиска слова в тексте

Алгоритм Бойера-Мура -- один из наиболее эффективных алгоритмов поиска подстроки в строке. 
Ключевая идея алгоритма состоит в том, что сравнение символов образца с текстом ведётся справа налево, что позволяет при несовпадении сдвигать образец сразу на несколько позиций.

В данной работе используется упрощённая версия алгоритма, основанная на правиле плохого символа. Для образца длиной $m$ строится таблица сдвигов: для каждого символа $c$, встречающегося в образце на позиции $i$ (не считая последнего символа), значение сдвига равно $m - 1 - i$. Если символ в образце не встречается, сдвиг равен $m$.

Алгоритм поиска работает следующим образом:

+ Образец выравнивается по левому краю текста, индекс $i$ указывает на последний символ текущего совмещения.
+ Символы сравниваются справа налево. Если все $m$ символов совпали -- вхождение найдено.
+ Если на позиции $k$ в тексте обнаружен "плохой" символ $c$ (не совпавший с соответствующим символом образца), выполняется сдвиг: $i = i + max(1, "shift"(c) - (m - 1 - j))$, где $j$ -- индекс несовпавшего символа в образце.
+ Шаги 2--3 повторяются до тех пор, пока $i < n$.

Поиск выполняется без учёта регистра: перед сравнением оба текста приводятся к нижнему регистру.

В системе алгоритм применяется в двух местах:

- при поиске книги по фрагменту ФИО автора(ов) или названия в ходе симметричного обхода АВЛ-дерева;
- при поиске читателя по фрагменту ФИО при полном переборе хеш-таблицы.

Временная сложность алгоритма составляет $O(n/m)$ в среднем случае и $O(n dot m)$ в наихудшем случае, однако на практике алгоритм работает значительно быстрее наивного поиска за счёт больших сдвигов при несовпадении.

=== Симметричный обход дерева

Симметричный обход (in-order traversal) -- это способ обхода двоичного дерева, при котором узлы посещаются в следующем порядке: сначала рекурсивно обходится левое поддерево, затем посещается текущий узел, затем рекурсивно обходится правое поддерево. Для двоичного дерева поиска симметричный обход гарантирует посещение узлов в порядке возрастания ключей.

Рекурсивная схема обхода узла $v$ имеет вид:

+ Если $v = $ null, завершить.
+ Обойти левое поддерево узла $v$.
+ Обработать узел $v$.
+ Обойти правое поддерево узла $v$.

В данной работе симметричный обход АВЛ-дерева применяется в двух случаях:

- при выводе полного списка книг -- результат выводится в порядке возрастания шифра, что соответствует естественной сортировке по тематическому разделу и порядковому номеру;
- при поиске книг по фрагменту ФИО автора(ов) или названия -- для каждого посещённого узла алгоритмом Бойера-Мура проверяется наличие заданного фрагмента в соответствующих полях книги.

Временная сложность полного симметричного обхода составляет $O(n)$, где $n$ -- число узлов в дереве, поскольку каждый узел посещается ровно один раз.

#pagebreak()
= Описание программы

== Описание структуры программы 
== Руководство пользователя

#pagebreak()
= Тестирование

#pagebreak()
#ch[ЗАКЛЮЧЕНИЕ]
#v(0.8em)

В ходе выполнения курсового проекта была разработана информационная система «Обслуживание читателей в библиотеке», предназначенная для автоматизации учета книжного фонда, регистрации читателей и контроля выдачи литературы.

В процессе реализации системы были решены следующие ключевые задачи:

+ Организация хранения данных: Для эффективного управления информацией были использованы комбинированные структуры данных. Использование хеш-таблицы с методом открытого хеширования позволило достичь высокой скорости доступа к данным о читателях по их номеру билета. Применение сбалансированного АВЛ-дерева для хранения сведений о книгах обеспечило стабильное время поиска и модификации данных ($O(log n)$), что критически важно при работе с большими объемами фондов.

+ Работа с динамическими структурами: Учет выдачи и приема книг реализован на базе слоеного списка (Skip List). Данная структура позволила совместить простоту реализации линейного списка с эффективностью поиска, близкой к бинарному дереву, а использование метода включения обеспечило корректную сортировку записей.Реализация механизмов поиска: Был успешно интегрирован алгоритм Бойера-Мура, который обеспечил быстрый поиск по текстовым фрагментам (ФИО авторов и названия книг) в процессе симметричного обхода дерева. Это позволило реализовать гибкий и производительный поиск даже при частичном совпадении данных.
+ Обеспечение целостности: В программе реализована логика, предотвращающая некорректные операции, такие как выдача отсутствующих экземпляров или удаление читателя, за которым числятся невозвращенные книги.

Разработанное программное обеспечение полностью соответствует требованиям технического задания. Тестирование подтвердило корректность работы всех алгоритмов и устойчивость системы при обработке различных сценариев взаимодействия пользователя с базой данных.

#pagebreak()
#ch("СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ")
#v(0.8em)

#pagebreak()
#{
  show heading: none
  align(heading([ПРИЛОЖЕНИЕ A. Код программы], numbering: none), center)
}

#align([*ПРИЛОЖЕНИЕ A. \ Код программы*], center)
#v(0.8em)